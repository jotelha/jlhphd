///////////////////////////////////////////////////////////////////////////////
//
// "Hyperslabing" by variable, 
//
// Original version included in NCO User Guide at http://nco.sf.net/nco.html#sort
//
// Modified for LAMMPS NetCDF trajectory.
//
// 2019, Johannes HÃ¶rmann, johannes.hoermann@imtek.uni-freiburg.de 
//
// execute with
//
//  ncap2 -D9 -v -O -S select.nco in.nc first_intermmediate.nc
//
// Afterwards, drop obsolete dimension with
//
//  ncks -O -x -v atom first_intermmediate.nc second_intermmediate.nc
//
// and rename the new output dimension
//
//  ncrename -O -d crd_out,atom second_intermmediate.nc final.out
//
///////////////////////////////////////////////////////////////////////////////
//
// The LAMMPS NetCDF structure is expected to comply with
//
//  netcdf frame0 {
//  dimensions:
//          frame = UNLIMITED ; // (1 currently)
//          atom = 547576 ;
//          Voigt = 6 ;
//          cell_angular = 3 ;
//          spatial = 3 ;
//          label = 10 ;
//          cell_spatial = 3 ;
//  variables:
//          float c_peratom_stress(frame, atom, Voigt) ;
//          double cell_angles(frame, cell_angular) ;
//                  cell_angles:units = "degree" ;
//          char cell_angular(spatial, label) ;
//          double cell_lengths(frame, cell_spatial) ;
//                  cell_lengths:units = "Angstrom" ;
//                  cell_lengths:scale_factor = 1. ;
//          double cell_origin(frame, cell_spatial) ;
//                  cell_origin:units = "Angstrom" ;
//                  cell_origin:scale_factor = 1. ;
//          char cell_spatial(spatial) ;
//          float coordinates(frame, atom, spatial) ;
//          float f_peratom_stress_ave(frame, atom, Voigt) ;
//          float f_storeAnteFreezeForces(frame, atom, spatial) ;
//          float f_storeAnteFreezeForcesAve(frame, atom, spatial) ;
//          float f_storeAnteShakeForces(frame, atom, spatial) ;
//          float f_storeAnteShakeForcesAve(frame, atom, spatial) ;
//          float f_storeAnteStatForces(frame, atom, spatial) ;
//          float f_storeAnteStatForcesAve(frame, atom, spatial) ;
//          float f_storeForcesAve(frame, atom, spatial) ;
//          float f_storeUnconstrainedForces(frame, atom, spatial) ;
//          float f_storeUnconstrainedForcesAve(frame, atom, spatial) ;
//          float forces(frame, atom, spatial) ;
//          int id(frame, atom) ;
//          float mass(frame, atom) ;
//          int mol(frame, atom) ;
//          char spatial(spatial) ;
//          double time(frame) ;
//                  time:units = "femtosecond" ;
//                  time:scale_factor = 2. ;
//          int type(frame, atom) ;
//          float velocities(frame, atom, spatial) ;
//  
//  // global attributes:
//                  :Conventions = "AMBER" ;
//                  :ConventionVersion = "1.0" ;
//                  :program = "LAMMPS" ;
//                  :programVersion = "16 Mar 2018" ;
//                  :history = "Mon Jul  1 19:32:18 2019: ncks -d frame,0 default.nc frame0.nc" ;
//                  :NCO = "netCDF Operators version 4.7.9 (Homepage = http://nco.sf.net, Code = http://github.com/nco/nco)" ;
//  data:
//  
//   cell_spatial = "" ;
//  
//   spatial = "" ;
//  }
//
///////////////////////////////////////////////////////////////////////////////
//
// Following fields are to be copied as they are:
//
//  double cell_angles(frame, cell_angular) ;
//          cell_angles:units = "degree" ;
//  char cell_angular(spatial, label) ;
//  double cell_lengths(frame, cell_spatial) ;
//          cell_lengths:units = "Angstrom" ;
//          cell_lengths:scale_factor = 1. ;
//  double cell_origin(frame, cell_spatial) ;
//          cell_origin:units = "Angstrom" ;
//          cell_origin:scale_factor = 1. ;
//  char cell_spatial(spatial) ;
//  char spatial(spatial) ;
//  double time(frame) ;
//          time:units = "femtosecond" ;
//          time:scale_factor = 2. ;
//
// Interestingly, all "scale_factor" attributes must be copied explicitly.
//
// Following fields are "hyperslabbed" by atom type:
//
//  float c_peratom_stress(frame, atom, Voigt) ;
//  float coordinates(frame, atom, spatial) ;
//  float f_peratom_stress_ave(frame, atom, Voigt) ;
//  float f_storeAnteFreezeForces(frame, atom, spatial) ;
//  float f_storeAnteFreezeForcesAve(frame, atom, spatial) ;
//  float f_storeAnteShakeForces(frame, atom, spatial) ;
//  float f_storeAnteShakeForcesAve(frame, atom, spatial) ;
//  float f_storeAnteStatForces(frame, atom, spatial) ;
//  float f_storeAnteStatForcesAve(frame, atom, spatial) ;
//  float f_storeForcesAve(frame, atom, spatial) ;
//  float f_storeUnconstrainedForces(frame, atom, spatial) ;
//  float f_storeUnconstrainedForcesAve(frame, atom, spatial) ;
//  float forces(frame, atom, spatial) ;
//  int id(frame, atom) ;
//  float mass(frame, atom) ;
//  int mol(frame, atom) ;
//  int type(frame, atom) ;
//  float velocities(frame, atom, spatial) ;
//
// Use and modify the following regex to manipulate 
// the list of variables above:
//
//    ^//  [^ ]* ([^(]*)\(.*$
//
///////////////////////////////////////////////////////////////////////////////



// Purpose: Save irregular 1-D regions based on variable values

// Included in NCO User Guide at http://nco.sf.net/nco.html#sort

/* NB: Single quotes around EOF above turn off shell parameter 
    expansion in "here documents". This in turn prevents the
    need for protecting dollarsign characters in NCO scripts with
    backslashes when the script is cut-and-pasted (aka "moused") 
    from an editor or e-mail into a shell console window */

/* Copy coordinates and variable(s) of interest into RAM variable(s)
   Benefits:
   1. ncap2 defines writes all variables on LHS of expression to disk
      Only exception is RAM variables, which are stored in RAM only
      Repeated operations on regular variables takes more time, 
      because changes are written to disk copy after every change.
      RAM variables are only changed in RAM so script works faster
      RAM variables can be written to disk at end with ram_write()
   2. Script permutes variables of interest during processing
      Safer to work with copies that have different names
      This discourages accidental, mistaken use of permuted versions
   3. Makes this script a more generic template:
      var_in instead of specific variable names everywhere */

*selection_criterion=11;

// var_in is the variable to define "hyperslab"
*var_in='type';

*var_c_peratom_stress=c_peratom_stress;
*var_coordinates=coordinates;
*var_f_peratom_stress_ave=f_peratom_stress_ave;
*var_f_storeAnteFreezeForces=f_storeAnteFreezeForces;
*var_f_storeAnteFreezeForcesAve=f_storeAnteFreezeForcesAve;
*var_f_storeAnteShakeForces=f_storeAnteShakeForces;
*var_f_storeAnteShakeForcesAve=f_storeAnteShakeForcesAve;
*var_f_storeAnteStatForces=f_storeAnteStatForces;
*var_f_storeAnteStatForcesAve=f_storeAnteStatForcesAve;
*var_f_storeForcesAve=f_storeForcesAve;
*var_f_storeUnconstrainedForces=f_storeUnconstrainedForces;
*var_f_storeUnconstrainedForcesAve=f_storeUnconstrainedForcesAve;
*var_forces=forces;
*var_id=id;
*var_mass=mass;
*var_mol=mol;
*var_type=type;
*var_velocities=velocities;

*dmn_in_sz=$atom.size; // [nbr] Size of input arrays

/* Create all other "intermediate" variables as RAM variables 
   to prevent them from cluttering the output file.
   Mask flag and sort map are same size as variable of interest */
*msk_flg=var_in;
*srt_map=var_in;

/* 
   In this example we mask for all values equal to 11.
   This is the key, problem-specific portion of the template
   Mask variable is Boolean: 1=Meets condition, 0=Fails condition */
where(var_in == selection_criterion) msk_flg=1; elsewhere msk_flg=0;

// print("msk_flg = ");print(msk_flg); // For debugging...

/* The sort() routine is overloaded, and takes one or two arguments
   The second argument (optional) is the "sort map" (srt_map below)
   Pass the sort map by reference, i.e., prefix with an ampersand
   If the sort map does not yet exist, then it will be created and 
   returned as an integer type the same shape as the input variable.
   The output of sort(), on the LHS, is a sorted version of the input
   msk_flg is not needed in its original order after sort()
   Hence we use msk_flg as both input to and output from sort()
   Doing this prevents the need to define a new, unneeded variable */
*msk_flg=sort(msk_flg,&srt_map);

// Count number of valid points in mask by summing the one's
*msk_nbr=msk_flg.total();

// Define output dimension equal in size to number of valid points
defdim("crd_out",msk_nbr);

//////////////////////////////
// (frame, atom) dimensions //
//////////////////////////////
/* Now sort the variable of interest using the sort map and remap()
   The output, on the LHS, is the input re-arranged so that all points
   meeting the mask condition are contiguous at the end of the array
   Use same srt_map to hyperslab multiple variables of the same shape
   Remember to apply srt_map to the coordinate variables */

// use following regex and replacement pattern for manipulation:
//  ^([^= ]*) *=remap\(([^,]*),(srt_map[^)]*)\);$
//  var_\1=remap(var_\2,\3);
//
// crd_in=remap(crd_in,srt_map);
// var_in=remap(var_in,srt_map);
var_id=remap(var_id,srt_map);
var_mass=remap(var_mass,srt_map);
var_mol=remap(var_mol,srt_map);
var_type=remap(var_type,srt_map);

///////////////////////////////////////
// (frame, atom, spatial) dimensions //
///////////////////////////////////////
/* Purpose: Sort multi-dimensional array based on coordinate values
   This example sorts the variable three_dmn_rec_var(time,lat,lon)
   based on the values of the time coordinate. */

// Included in NCO User Guide at http://nco.sf.net/nco.html#sort

/* sort() always sorts in ascending order
   The associated sort map therefore re-arranges the original,
   randomized time array into ascending order.
   There are two methods to obtain the descending order the user wants
   1) We could solve the problem in ascending order (the default)
   and then apply the reverse() method to re-arrange the results.
   2) We could change the sort map to return things in descending
   order of time and solve the problem directly in descending order. */

// Following shows how to do method one:

/* Expand the sort map to srt_map_3d, the size of the data array
   1. Use data array to provide right shape for the expanded sort map
   2. Coerce data array into an integer so srt_map_3d is an integer
   3. Multiply data array by zero so 3-d map elements are all zero
   4. Add the 1-d sort map to the 3-d sort map (NCO automatically resizes)
   5. Add the spatial (lat,lon) offsets to each time index 
   6. de-sort using the srt_map_3d
   7. Use reverse to obtain descending in time order
   Loops could accomplish the same thing (exercise left for reader)
   However, loops are slow for large datasets */

/* Following index manipulation requires understanding correspondence
   between 1-d (unrolled, memory order of storage) and access into that
   memory as a multidimensional (3-d, in this case) rectangular array.
   Key idea to understand is how dimensionality affects offsets */ 

// Use "coordinates" as 3d reference
*three_dmn_rec_var=coordinates;

// Copy 1-d sort map into 3-d sort map
*srt_map_3d=(0*int(three_dmn_rec_var))+srt_map;
// Multiply base offset by factorial of lesser dimensions
srt_map_3d*=$spatial.size;
*spatial_idx=array(0,1,$spatial);
srt_map_3d+=spatial_idx;

// print("sort map 3d =\n");print(srt_map_3d);

// Use remap() to re-map the data
// three_dmn_rec_var=remap(three_dmn_rec_var,srt_map_3d);
var_coordinates=remap(var_coordinates,srt_map_3d);
var_f_storeAnteFreezeForces=remap(var_f_storeAnteFreezeForces,srt_map_3d);
var_f_storeAnteFreezeForcesAve=remap(var_f_storeAnteFreezeForcesAve,srt_map_3d);
var_f_storeAnteShakeForces=remap(var_f_storeAnteShakeForces,srt_map_3d);
var_f_storeAnteShakeForcesAve=remap(var_f_storeAnteShakeForcesAve,srt_map_3d);
var_f_storeAnteStatForces=remap(var_f_storeAnteStatForces,srt_map_3d);
var_f_storeAnteStatForcesAve=remap(var_f_storeAnteStatForcesAve,srt_map_3d);
var_f_storeForcesAve=remap(var_f_storeForcesAve,srt_map_3d);
var_f_storeUnconstrainedForces=remap(var_f_storeUnconstrainedForces,srt_map_3d);
var_f_storeUnconstrainedForcesAve=remap(var_f_storeUnconstrainedForcesAve,srt_map_3d);
var_forces=remap(var_forces,srt_map_3d);
var_velocities=remap(var_velocities,srt_map_3d);


/////////////////////////////////////
// (frame, atom, Voigt) dimensions //
/////////////////////////////////////

// Use "c_peratom_stress" as 6d reference
*six_dmn_rec_var=c_peratom_stress;

// Copy 1-d sort map into 6-d sort map
*srt_map_6d=(0*int(six_dmn_rec_var))+srt_map;
// Multiply base offset by factorial of lesser dimensions
srt_map_6d*=$Voigt.size;
*Voigt_idx=array(0,1,$Voigt);
srt_map_6d+=Voigt_idx;

// Use remap() to re-map the data
// six_dmn_rec_var=remap(six_dmn_rec_var,srt_map_6d);
var_c_peratom_stress=remap(var_c_peratom_stress,srt_map_6d);
var_f_peratom_stress_ave=remap(var_f_peratom_stress_ave,srt_map_6d);

//////////////////
// write output //
//////////////////

cell_angles=cell_angles;
cell_angular=cell_angular;
cell_lengths=cell_lengths;
cell_origin=cell_origin;
cell_spatial=cell_spatial;
spatial=spatial;
time=time;

cell_lengths@scale_factor=cell_lengths@scale_factor;
cell_origin@scale_factor=cell_origin@scale_factor;
time@scale_factor=time@scale_factor;

/* Hyperslab last msk_nbr values of variable(s) of interest */
// use regex and replacement pattern for maniulation:
//   ^([^=]*=)([^(]*\(.*)$
//   \1var_\2

// crd_out[crd_out]=crd_in((dmn_in_sz-msk_nbr):(dmn_in_sz-1));
// var_out[crd_out]=var_in((dmn_in_sz-msk_nbr):(dmn_in_sz-1));

// Hyperslab variables of dimensions (frame,atom) 
id[frame,crd_out]=var_id(:,(dmn_in_sz-msk_nbr):(dmn_in_sz-1));
mass[frame,crd_out]=var_mass(:,(dmn_in_sz-msk_nbr):(dmn_in_sz-1));
mol[frame,crd_out]=var_mol(:,(dmn_in_sz-msk_nbr):(dmn_in_sz-1));
'type'[frame,crd_out]=var_type(:,(dmn_in_sz-msk_nbr):(dmn_in_sz-1));

// Hyperslab variables of dimensions (frame,atom,spatial) 
coordinates[frame,crd_out,spatial]=var_coordinates(:,(dmn_in_sz-msk_nbr):(dmn_in_sz-1),:);
velocities[frame,crd_out,spatial]=var_velocities(:,(dmn_in_sz-msk_nbr):(dmn_in_sz-1),:);
forces[frame,crd_out,spatial]=var_forces(:,(dmn_in_sz-msk_nbr):(dmn_in_sz-1),:);
f_storeAnteFreezeForces[frame,crd_out,spatial]=var_f_storeAnteFreezeForces(:,(dmn_in_sz-msk_nbr):(dmn_in_sz-1),:);
f_storeAnteFreezeForcesAve[frame,crd_out,spatial]=var_f_storeAnteFreezeForcesAve(:,(dmn_in_sz-msk_nbr):(dmn_in_sz-1),:);
f_storeAnteShakeForces[frame,crd_out,spatial]=var_f_storeAnteShakeForces(:,(dmn_in_sz-msk_nbr):(dmn_in_sz-1),:);
f_storeAnteShakeForcesAve[frame,crd_out,spatial]=var_f_storeAnteShakeForcesAve(:,(dmn_in_sz-msk_nbr):(dmn_in_sz-1),:);
f_storeAnteStatForces[frame,crd_out,spatial]=var_f_storeAnteStatForces(:,(dmn_in_sz-msk_nbr):(dmn_in_sz-1),:);
f_storeAnteStatForcesAve[frame,crd_out,spatial]=var_f_storeAnteStatForcesAve(:,(dmn_in_sz-msk_nbr):(dmn_in_sz-1),:);
f_storeForcesAve[frame,crd_out,spatial]=var_f_storeForcesAve(:,(dmn_in_sz-msk_nbr):(dmn_in_sz-1),:);
f_storeUnconstrainedForces[frame,crd_out,spatial]=var_f_storeUnconstrainedForces(:,(dmn_in_sz-msk_nbr):(dmn_in_sz-1),:);
f_storeUnconstrainedForcesAve[frame,crd_out,spatial]=var_f_storeUnconstrainedForcesAve(:,(dmn_in_sz-msk_nbr):(dmn_in_sz-1),:);

// Hyperslab variables of dimensions (frame,atom,Voigt) 
c_peratom_stress[frame,crd_out,Voigt]=var_c_peratom_stress(:,(dmn_in_sz-msk_nbr):(dmn_in_sz-1),:);
f_peratom_stress_ave[frame,crd_out,Voigt]=var_f_peratom_stress_ave(:,(dmn_in_sz-msk_nbr):(dmn_in_sz-1),:);
