///////////////////////////////////////////////////////////////////////////////
//
// "Hyperslabing" by variable along dimension "atom", 
//
// Original version included in NCO User Guide at http://nco.sf.net/nco.html#sort
//
// Modified for LAMMPS NetCDF trajectory.
//
// 2019, Johannes HÃ¶rmann, johannes.hoermann@imtek.uni-freiburg.de 
//
// execute with
//
//  ncap2 -D9 -v -O -S select.nco in.nc first_intermmediate.nc
//
// Afterwards, drop obsolete dimension with
//
//  ncks -O -x -v atom first_intermmediate.nc second_intermmediate.nc
//
// and rename the new output dimension
//
//  ncrename -O -d atom_out,atom second_intermmediate.nc final.out
//
///////////////////////////////////////////////////////////////////////////////
//
// The LAMMPS NetCDF structure is expected to comply with (ncinfo output)
//
//  <class 'netCDF4._netCDF4.Dataset'>
//  root group (NETCDF3_64BIT_OFFSET data model, file format NETCDF3):
//      Conventions: AMBER
//      ConventionVersion: 1.0
//      program: LAMMPS
//      programVersion: 16 Mar 2018
//      dimensions(sizes): spatial(3), label(10), frame(351), cell_spatial(3),
//        cell_angular(3), atom(547576), Voigt(6)
//      variables(dimensions): |S1 spatial(spatial), |S1 cell_spatial(spatial),
//        |S1 cell_angular(spatial,label), float64 time(frame),
//        float64 cell_origin(frame,cell_spatial),
//        float64 cell_lengths(frame,cell_spatial),
//        float64 cell_angles(frame,cell_angular),
//        int32 id(frame,atom), int32 mol(frame,atom), int32 type(frame,atom),
//        float32 mass(frame,atom), float32 coordinates(frame,atom,spatial),
//        float32 velocities(frame,atom,spatial),
//        float32 forces(frame,atom,spatial),
//        float32 f_storeAnteShakeForces(frame,atom,spatial),
//        float32 f_storeAnteStatForces(frame,atom,spatial),
//        float32 f_storeAnteFreezeForces(frame,atom,spatial),
//        float32 f_storeUnconstrainedForces(frame,atom,spatial),
//        float32 f_storeForcesAve(frame,atom,spatial),
//        float32 f_storeAnteShakeForcesAve(frame,atom,spatial),
//        float32 f_storeAnteStatForcesAve(frame,atom,spatial),
//        float32 f_storeAnteFreezeForcesAve(frame,atom,spatial),
//        float32 f_storeUnconstrainedForcesAve(frame,atom,spatial),
//        float32 c_peratom_stress(frame,atom,Voigt),
//        float32 f_peratom_stress_ave(frame,atom,Voigt)
//
// or (ncdump -c output)
//
//  netcdf frame0 {
//  dimensions:
//          frame = UNLIMITED ; // (1 currently)
//          atom = 547576 ;
//          Voigt = 6 ;
//          cell_angular = 3 ;
//          spatial = 3 ;
//          label = 10 ;
//          cell_spatial = 3 ;
//  variables:
//          float c_peratom_stress(frame, atom, Voigt) ;
//          double cell_angles(frame, cell_angular) ;
//                  cell_angles:units = "degree" ;
//          char cell_angular(spatial, label) ;
//          double cell_lengths(frame, cell_spatial) ;
//                  cell_lengths:units = "Angstrom" ;
//                  cell_lengths:scale_factor = 1. ;
//          double cell_origin(frame, cell_spatial) ;
//                  cell_origin:units = "Angstrom" ;
//                  cell_origin:scale_factor = 1. ;
//          char cell_spatial(spatial) ;
//          float coordinates(frame, atom, spatial) ;
//          float f_peratom_stress_ave(frame, atom, Voigt) ;
//          float f_storeAnteFreezeForces(frame, atom, spatial) ;
//          float f_storeAnteFreezeForcesAve(frame, atom, spatial) ;
//          float f_storeAnteShakeForces(frame, atom, spatial) ;
//          float f_storeAnteShakeForcesAve(frame, atom, spatial) ;
//          float f_storeAnteStatForces(frame, atom, spatial) ;
//          float f_storeAnteStatForcesAve(frame, atom, spatial) ;
//          float f_storeForcesAve(frame, atom, spatial) ;
//          float f_storeUnconstrainedForces(frame, atom, spatial) ;
//          float f_storeUnconstrainedForcesAve(frame, atom, spatial) ;
//          float forces(frame, atom, spatial) ;
//          int id(frame, atom) ;
//          float mass(frame, atom) ;
//          int mol(frame, atom) ;
//          char spatial(spatial) ;
//          double time(frame) ;
//                  time:units = "femtosecond" ;
//                  time:scale_factor = 2. ;
//          int type(frame, atom) ;
//          float velocities(frame, atom, spatial) ;
//  
//  // global attributes:
//                  :Conventions = "AMBER" ;
//                  :ConventionVersion = "1.0" ;
//                  :program = "LAMMPS" ;
//                  :programVersion = "16 Mar 2018" ;
//                  :history = "Mon Jul  1 19:32:18 2019: ncks -d frame,0 default.nc frame0.nc" ;
//                  :NCO = "netCDF Operators version 4.7.9 (Homepage = http://nco.sf.net, Code = http://github.com/nco/nco)" ;
//  data:
//  
//   cell_spatial = "" ;
//  
//   spatial = "" ;
//  }
//
///////////////////////////////////////////////////////////////////////////////
//
// Following fields are to be copied as they are:
//
//  double cell_angles(frame, cell_angular) ;
//          cell_angles:units = "degree" ;
//  char cell_angular(spatial, label) ;
//  double cell_lengths(frame, cell_spatial) ;
//          cell_lengths:units = "Angstrom" ;
//          cell_lengths:scale_factor = 1. ;
//  double cell_origin(frame, cell_spatial) ;
//          cell_origin:units = "Angstrom" ;
//          cell_origin:scale_factor = 1. ;
//  char cell_spatial(spatial) ;
//  char spatial(spatial) ;
//  double time(frame) ;
//          time:units = "femtosecond" ;
//          time:scale_factor = 2. ;
//
// Interestingly, all "scale_factor" attributes must be copied explicitly.
//
// Following fields are "hyperslabbed" by atom type:
//
//  float c_peratom_stress(frame, atom, Voigt) ;
//  float coordinates(frame, atom, spatial) ;
//  float f_peratom_stress_ave(frame, atom, Voigt) ;
//  float f_storeAnteFreezeForces(frame, atom, spatial) ;
//  float f_storeAnteFreezeForcesAve(frame, atom, spatial) ;
//  float f_storeAnteShakeForces(frame, atom, spatial) ;
//  float f_storeAnteShakeForcesAve(frame, atom, spatial) ;
//  float f_storeAnteStatForces(frame, atom, spatial) ;
//  float f_storeAnteStatForcesAve(frame, atom, spatial) ;
//  float f_storeForcesAve(frame, atom, spatial) ;
//  float f_storeUnconstrainedForces(frame, atom, spatial) ;
//  float f_storeUnconstrainedForcesAve(frame, atom, spatial) ;
//  float forces(frame, atom, spatial) ;
//  int id(frame, atom) ;
//  float mass(frame, atom) ;
//  int mol(frame, atom) ;
//  int type(frame, atom) ;
//  float velocities(frame, atom, spatial) ;
//
// Use and modify the following regex to manipulate 
// the list of variables above:
//
//    ^//  [^ ]* ([^(]*)\(.*$
//
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////
// interoduce new dimension //
//////////////////////////////

// Included in NCO User Guide at http://nco.sf.net/nco.html#sort

/* NB: Single quotes around EOF above turn off shell parameter 
    expansion in "here documents". This in turn prevents the
    need for protecting dollarsign characters in NCO scripts with
    backslashes when the script is cut-and-pasted (aka "moused") 
    from an editor or e-mail into a shell console window */

/* Copy coordinates and variable(s) of interest into RAM variable(s)
   Benefits:
   1. ncap2 defines writes all variables on LHS of expression to disk
      Only exception is RAM variables, which are stored in RAM only
      Repeated operations on regular variables takes more time, 
      because changes are written to disk copy after every change.
      RAM variables are only changed in RAM so script works faster
      RAM variables can be written to disk at end with ram_write()
   2. Script permutes variables of interest during processing
      Safer to work with copies that have different names
      This discourages accidental, mistaken use of permuted versions
   3. Makes this script a more generic template:
      var_in instead of specific variable names everywhere */

// select first frame as reference

*dmn_in_sz=$atom.size; // size of input arrays in the dimension to filter

// use atom type and z-position for masking
*var_id[$atom]=id(0,:);

// sort by atom id (ascending)
// allocate mask and sort map of desired size
*id_srt_map=var_id*0;
*var_id=sort(var_id,&id_srt_map);
var_id.ram_delete();

*var_type[$atom]='type'(0,:);
*var_type=remap(var_type,id_srt_map);

*var_zpos[$atom]=coordinates(0,:,2);
*var_zpos=remap(var_zpos,id_srt_map);

// allocate mask and sort map of desired size
*msk_flg=var_type*0;
*srt_map=var_type*0;

// chose all atoms of type 11 (Au) and of z position > 5 Angstrom
where( (var_type == 11) && (var_zpos > 5.) ) msk_flg=1; elsewhere msk_flg=0;
/* The sort() routine is overloaded, and takes one or two arguments
   The second argument (optional) is the "sort map" (srt_map below)
   Pass the sort map by reference, i.e., prefix with an ampersand
   If the sort map does not yet exist, then it will be created and 
   returned as an integer type the same shape as the input variable.
   The output of sort(), on the LHS, is a sorted version of the input
   msk_flg is not needed in its original order after sort()
   Hence we use msk_flg as both input to and output from sort()
   Doing this prevents the need to define a new, unneeded variable */
var_type.ram_delete();
var_zpos.ram_delete();

*msk_flg=sort(msk_flg,&srt_map);
// now, if atoms are always sorted by atom id, the constructed map and mask
// must be valid for any frame as long as atom ids do not change

// Count number of valid points in mask by summing the one's
*msk_nbr=msk_flg.total();

// delete obsolete RAM variables here
msk_flg.ram_delete();
// keep srt_map for every frame

/////////////////////////////////////////
// construct sort map for 3d variables //
/////////////////////////////////////////

// Use "coordinates" as 3d reference
*var_coordinates[$atom,$spatial]=coordinates(0,:,:);
*three_dmn_rec_var=var_coordinates;
var_coordinates.ram_delete();

// Copy 1-d sort map into 3-d sort map
*srt_map_3d=(0*int(three_dmn_rec_var))+srt_map;
// Multiply base offset by factorial of lesser dimensions
srt_map_3d*=$spatial.size;
*spatial_idx=array(0,1,$spatial);
srt_map_3d+=spatial_idx;

/////////////////////////////////////////
// construct sort map for 6d variables //
/////////////////////////////////////////

// Use "c_peratom_stress" as 6d reference
*var_c_peratom_stress[$atom,$Voigt]=c_peratom_stress(0,:,:);
*six_dmn_rec_var=var_c_peratom_stress;
var_c_peratom_stress.ram_delete();

// Copy 1-d sort map into 6-d sort map
*srt_map_6d=(0*int(six_dmn_rec_var))+srt_map;
// Multiply base offset by factorial of lesser dimensions
srt_map_6d*=$Voigt.size;
*Voigt_idx=array(0,1,$Voigt);
srt_map_6d+=Voigt_idx;

//////////////////////////////////////
// allocate intermmediate variables //
//////////////////////////////////////

// Store input variables in RAM 
// before overwriting them with output initialization

*in_id=id;
*in_mass=mass;
*in_mol=mol;
*in_type='type';

*in_coordinates=coordinates;
*in_velocities=velocities;
*in_forces=forces;
*in_f_storeAnteFreezeForces=f_storeAnteFreezeForces;
*in_f_storeAnteFreezeForcesAve=f_storeAnteFreezeForcesAve;
*in_f_storeAnteShakeForces=f_storeAnteShakeForces;
*in_f_storeAnteShakeForcesAve=f_storeAnteShakeForcesAve;
*in_f_storeAnteStatForces=f_storeAnteStatForces;
*in_f_storeAnteStatForcesAve=f_storeAnteStatForcesAve;
*in_f_storeForcesAve=f_storeForcesAve;
*in_f_storeUnconstrainedForces=f_storeUnconstrainedForces;
*in_f_storeUnconstrainedForcesAve=f_storeUnconstrainedForcesAve;

*in_c_peratom_stress=c_peratom_stress;
*in_f_peratom_stress_ave=f_peratom_stress_ave;

///////////////////////////////
// allocate output variables //
///////////////////////////////

// Define output dimension equal in size to number of valid points
defdim("atom_out",msk_nbr);

cell_angles=cell_angles;
cell_angular=cell_angular;
cell_lengths=cell_lengths;
cell_origin=cell_origin;
cell_spatial=cell_spatial;
spatial=spatial;
time=time;

cell_lengths@scale_factor=cell_lengths@scale_factor;
cell_origin@scale_factor=cell_origin@scale_factor;
time@scale_factor=time@scale_factor;

// initialize output
// number literal samples from http://nco.sourceforge.net/nco.html#Number-literals:

// var[$rlev]=0.1;     // Variable will be type @code{NC_DOUBLE}
// var[$lon_grd]=2.0;  // Variable will be type @code{NC_DOUBLE}
// var[$gds_crd]=2e3;  // Variable will be type @code{NC_DOUBLE}
// var[$gds_crd]=2.0f; // Variable will be type @code{NC_FLOAT} (note "f")
// var[$gds_crd]=2e3f; // Variable will be type @code{NC_FLOAT} (note "f")
// var[$gds_crd]=2;    // Variable will be type @code{NC_INT}
// var[$gds_crd]=-3;   // Variable will be type @code{NC_INT}
// var[$gds_crd]=2s;   // Variable will be type @code{NC_SHORT}
// var[$gds_crd]=-3s;  // Variable will be type @code{NC_SHORT}
// var@att=41.;        // Attribute will be type @code{NC_DOUBLE}
// var@att=41.f;       // Attribute will be type @code{NC_FLOAT}
// var@att=41;         // Attribute will be type @code{NC_INT}
// var@att=-21s;       // Attribute will be type @code{NC_SHORT}  
// var@units="kelvin"; // Attribute will be type @code{NC_CHAR}

id[$frame,$atom_out]=0;
mass[$frame,$atom_out]=0.f;
mol[$frame,$atom_out]=0;
type[$frame,$atom_out]=0;

coordinates[$frame,$atom_out,$spatial]=0.f;
velocities[$frame,$atom_out,$spatial]=0.f;
forces[$frame,$atom_out,$spatial]=0.f;
f_storeAnteFreezeForces[$frame,$atom_out,$spatial]=0.f;
f_storeAnteFreezeForcesAve[$frame,$atom_out,$spatial]=0.f;
f_storeAnteShakeForces[$frame,$atom_out,$spatial]=0.f;
f_storeAnteShakeForcesAve[$frame,$atom_out,$spatial]=0.f;
f_storeAnteStatForces[$frame,$atom_out,$spatial]=0.f;
f_storeAnteStatForcesAve[$frame,$atom_out,$spatial]=0.f;
f_storeForcesAve[$frame,$atom_out,$spatial]=0.f;
f_storeUnconstrainedForces[$frame,$atom_out,$spatial]=0.f;
f_storeUnconstrainedForcesAve[$frame,$atom_out,$spatial]=0.f;

c_peratom_stress[$frame,$atom_out,$Voigt]=0.f;
f_peratom_stress_ave[$frame,$atom_out,$Voigt]=0.f;

/////////////////////////////
// iterate over all frames //
/////////////////////////////

*sz_idx=$frame.size;

for(*idx=0; idx<sz_idx;idx++) {
  *var_id=in_id(idx,:);
  *var_mass=in_mass(idx,:);
  *var_mol=in_mol(idx,:);
  *var_type=in_type(idx,:);

  *var_coordinates=in_coordinates(idx,:,:);
  *var_velocities=in_velocities(idx,:,:);
  *var_forces=in_forces(idx,:,:);
  *var_f_storeAnteFreezeForces=in_f_storeAnteFreezeForces(idx,:,:);
  *var_f_storeAnteFreezeForcesAve=in_f_storeAnteFreezeForcesAve(idx,:,:);
  *var_f_storeAnteShakeForces=in_f_storeAnteShakeForces(idx,:,:);
  *var_f_storeAnteShakeForcesAve=in_f_storeAnteShakeForcesAve(idx,:,:);
  *var_f_storeAnteStatForces=in_f_storeAnteStatForces(idx,:,:);
  *var_f_storeAnteStatForcesAve=in_f_storeAnteStatForcesAve(idx,:,:);
  *var_f_storeForcesAve=in_f_storeForcesAve(idx,:,:);
  *var_f_storeUnconstrainedForces=in_f_storeUnconstrainedForces(idx,:,:);
  *var_f_storeUnconstrainedForcesAve=in_f_storeUnconstrainedForcesAve(idx,:,:);

  *var_c_peratom_stress=in_c_peratom_stress(idx,:,:);
  *var_f_peratom_stress_ave=in_f_peratom_stress_ave(idx,:,:);

  /////////////////////
  // sort by atom id //
  /////////////////////

  *id_srt_map=0*var_id;
  *var_id=sort(var_id,&id_srt_map);

  // (frame, atom) dimensions
  // *var_id=remap(var_id,id_srt_map); // done above
  *var_mass=remap(var_mass,id_srt_map);
  *var_mol=remap(var_mol,id_srt_map);
  *var_type=remap(var_type,id_srt_map);

  // (frame, atom, spatial) dimensions
  *id_srt_map_3d=(0*int(three_dmn_rec_var))+id_srt_map;
  id_srt_map_3d*=$spatial.size;
  id_srt_map_3d+=spatial_idx;

  *var_coordinates=remap(var_coordinates,id_srt_map_3d);
  *var_f_storeAnteFreezeForces=remap(var_f_storeAnteFreezeForces,id_srt_map_3d);
  *var_f_storeAnteFreezeForcesAve=remap(var_f_storeAnteFreezeForcesAve,id_srt_map_3d);
  *var_f_storeAnteShakeForces=remap(var_f_storeAnteShakeForces,id_srt_map_3d);
  *var_f_storeAnteShakeForcesAve=remap(var_f_storeAnteShakeForcesAve,id_srt_map_3d);
  *var_f_storeAnteStatForces=remap(var_f_storeAnteStatForces,id_srt_map_3d);
  *var_f_storeAnteStatForcesAve=remap(var_f_storeAnteStatForcesAve,id_srt_map_3d);
  *var_f_storeForcesAve=remap(var_f_storeForcesAve,id_srt_map_3d);
  *var_f_storeUnconstrainedForces=remap(var_f_storeUnconstrainedForces,id_srt_map_3d);
  *var_f_storeUnconstrainedForcesAve=remap(var_f_storeUnconstrainedForcesAve,id_srt_map_3d);
  *var_forces=remap(var_forces,id_srt_map_3d);
  *var_velocities=remap(var_velocities,id_srt_map_3d);

  // (frame, atom, Voigt) dimensions
  *id_srt_map_6d=(0*int(six_dmn_rec_var))+id_srt_map;
  id_srt_map_6d*=$Voigt.size;
  id_srt_map_6d+=Voigt_idx;
  *var_c_peratom_stress=remap(var_c_peratom_stress,id_srt_map_6d);
  *var_f_peratom_stress_ave=remap(var_f_peratom_stress_ave,id_srt_map_6d);

  id_srt_map.ram_delete();
  id_srt_map_3d.ram_delete();
  id_srt_map_6d.ram_delete();

  /////////////////////////
  // sort by binary mask //
  /////////////////////////

  // (frame, atom) dimensions //
  /* Now sort the variable of interest using the sort map and remap()
     The output, on the LHS, is the input re-arranged so that all points
     meeting the mask condition are contiguous at the end of the array
     Use same srt_map to hyperslab multiple variables of the same shape
     Remember to apply srt_map to the coordinate variables */

  // use following regex and replacement pattern for manipulation:
  //  ^([^= ]*) *=remap\(([^,]*),(srt_map[^)]*)\);$
  //  var_\1=remap(var_\2,\3);
  //
  // crd_in=remap(crd_in,srt_map);
  // var_in=remap(var_in,srt_map);
  *var_id=remap(var_id,srt_map);
  *var_mass=remap(var_mass,srt_map);
  *var_mol=remap(var_mol,srt_map);
  *var_type=remap(var_type,srt_map);

  // (frame, atom, spatial) dimensions //
  /* Purpose: Sort multi-dimensional array based on coordinate values
     This example sorts the variable three_dmn_rec_var(time,lat,lon)
     based on the values of the time coordinate. */

  // Included in NCO User Guide at http://nco.sf.net/nco.html#sort

  /* sort() always sorts in ascending order
     The associated sort map therefore re-arranges the original,
     randomized time array into ascending order.
     There are two methods to obtain the descending order the user wants
     1) We could solve the problem in ascending order (the default)
     and then apply the reverse() method to re-arrange the results.
     2) We could change the sort map to return things in descending
     order of time and solve the problem directly in descending order. */

  // Following shows how to do method one:

  /* Expand the sort map to srt_map_3d, the size of the data array
     1. Use data array to provide right shape for the expanded sort map
     2. Coerce data array into an integer so srt_map_3d is an integer
     3. Multiply data array by zero so 3-d map elements are all zero
     4. Add the 1-d sort map to the 3-d sort map (NCO automatically resizes)
     5. Add the spatial (lat,lon) offsets to each time index 
     6. de-sort using the srt_map_3d
     7. Use reverse to obtain descending in time order
     Loops could accomplish the same thing (exercise left for reader)
     However, loops are slow for large datasets */

  /* Following index manipulation requires understanding correspondence
     between 1-d (unrolled, memory order of storage) and access into that
     memory as a multidimensional (3-d, in this case) rectangular array.
     Key idea to understand is how dimensionality affects offsets */ 

  // Use remap() to re-map the data
  // three_dmn_rec_var=remap(three_dmn_rec_var,srt_map_3d);
  *var_coordinates=remap(var_coordinates,srt_map_3d);
  *var_f_storeAnteFreezeForces=remap(var_f_storeAnteFreezeForces,srt_map_3d);
  *var_f_storeAnteFreezeForcesAve=remap(var_f_storeAnteFreezeForcesAve,srt_map_3d);
  *var_f_storeAnteShakeForces=remap(var_f_storeAnteShakeForces,srt_map_3d);
  *var_f_storeAnteShakeForcesAve=remap(var_f_storeAnteShakeForcesAve,srt_map_3d);
  *var_f_storeAnteStatForces=remap(var_f_storeAnteStatForces,srt_map_3d);
  *var_f_storeAnteStatForcesAve=remap(var_f_storeAnteStatForcesAve,srt_map_3d);
  *var_f_storeForcesAve=remap(var_f_storeForcesAve,srt_map_3d);
  *var_f_storeUnconstrainedForces=remap(var_f_storeUnconstrainedForces,srt_map_3d);
  *var_f_storeUnconstrainedForcesAve=remap(var_f_storeUnconstrainedForcesAve,srt_map_3d);
  *var_forces=remap(var_forces,srt_map_3d);
  *var_velocities=remap(var_velocities,srt_map_3d);

  // (frame, atom, Voigt) dimensions //
  // Use remap() to re-map the data
  // six_dmn_rec_var=remap(six_dmn_rec_var,srt_map_6d);
  *var_c_peratom_stress=remap(var_c_peratom_stress,srt_map_6d);
  *var_f_peratom_stress_ave=remap(var_f_peratom_stress_ave,srt_map_6d);


  /////////////////////////
  // hyperslab to output //
  /////////////////////////

  /* Hyperslab last msk_nbr values of variable(s) of interest */
  // use regex and replacement pattern for maniulation:
  //   ^([^=]*=)([^(]*\(.*)$
  //   \1var_\2

  // atom_out[atom_out]=crd_in((dmn_in_sz-msk_nbr):(dmn_in_sz-1));
  // var_out[atom_out]=var_in((dmn_in_sz-msk_nbr):(dmn_in_sz-1));

  // Hyperslab variables of dimensions (frame,atom) 
  id(idx,:)=var_id((dmn_in_sz-msk_nbr):(dmn_in_sz-1));
  mass(idx,:)=var_mass((dmn_in_sz-msk_nbr):(dmn_in_sz-1));
  mol(idx,:)=var_mol((dmn_in_sz-msk_nbr):(dmn_in_sz-1));
  'type'(idx,:)=var_type((dmn_in_sz-msk_nbr):(dmn_in_sz-1));

  // Hyperslab variables of dimensions (frame,atom,spatial) 
  coordinates(idx,:,:)=var_coordinates((dmn_in_sz-msk_nbr):(dmn_in_sz-1),:);
  velocities(idx,:,:)=var_velocities((dmn_in_sz-msk_nbr):(dmn_in_sz-1),:);
  forces(idx,:,:)=var_forces((dmn_in_sz-msk_nbr):(dmn_in_sz-1),:);
  f_storeAnteFreezeForces(idx,:,:)=var_f_storeAnteFreezeForces((dmn_in_sz-msk_nbr):(dmn_in_sz-1),:);
  f_storeAnteFreezeForcesAve(idx,:,:)=var_f_storeAnteFreezeForcesAve((dmn_in_sz-msk_nbr):(dmn_in_sz-1),:);
  f_storeAnteShakeForces(idx,:,:)=var_f_storeAnteShakeForces((dmn_in_sz-msk_nbr):(dmn_in_sz-1),:);
  f_storeAnteShakeForcesAve(idx,:,:)=var_f_storeAnteShakeForcesAve((dmn_in_sz-msk_nbr):(dmn_in_sz-1),:);
  f_storeAnteStatForces(idx,:,:)=var_f_storeAnteStatForces((dmn_in_sz-msk_nbr):(dmn_in_sz-1),:);
  f_storeAnteStatForcesAve(idx,:,:)=var_f_storeAnteStatForcesAve((dmn_in_sz-msk_nbr):(dmn_in_sz-1),:);
  f_storeForcesAve(idx,:,:)=var_f_storeForcesAve((dmn_in_sz-msk_nbr):(dmn_in_sz-1),:);
  f_storeUnconstrainedForces(idx,:,:)=var_f_storeUnconstrainedForces((dmn_in_sz-msk_nbr):(dmn_in_sz-1),:);
  f_storeUnconstrainedForcesAve(idx,:,:)=var_f_storeUnconstrainedForcesAve((dmn_in_sz-msk_nbr):(dmn_in_sz-1),:);

  // Hyperslab variables of dimensions (frame,atom,Voigt) 
  c_peratom_stress(idx,:,:)=var_c_peratom_stress((dmn_in_sz-msk_nbr):(dmn_in_sz-1),:);
  f_peratom_stress_ave(idx,:,:)=var_f_peratom_stress_ave((dmn_in_sz-msk_nbr):(dmn_in_sz-1),:);
}

// delete temporary variables
var_id.ram_delete();
var_mass.ram_delete();
var_mol.ram_delete();
var_type.ram_delete();

var_coordinates.ram_delete();
var_velocities.ram_delete();
var_forces.ram_delete();
var_f_storeAnteFreezeForces.ram_delete();
var_f_storeAnteFreezeForcesAve.ram_delete();
var_f_storeAnteShakeForces.ram_delete();
var_f_storeAnteShakeForcesAve.ram_delete();
var_f_storeAnteStatForces.ram_delete();
var_f_storeAnteStatForcesAve.ram_delete();
var_f_storeForcesAve.ram_delete();
var_f_storeUnconstrainedForces.ram_delete();
var_f_storeUnconstrainedForcesAve.ram_delete();

var_c_peratom_stress.ram_delete();
var_f_peratom_stress_ave.ram_delete();

srt_map.ram_delete();
srt_map_3d.ram_delete();
srt_map_6d.ram_delete();

three_dmn_rec_var.ram_delete();
six_dmn_rec_var.ram_delete();

spatial_idx.ram_delete();
Voigt_idx.ram_delete();
