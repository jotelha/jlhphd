{% extends "fw_base.yaml" %}
{% block body %}
{# automatically determine indices of frames to extract #}
{%- if first_frame_to_extract is undefined -%}
{%- set first_frame_to_extract = 0 -%}
{%- endif -%}
{%- if last_frame_to_extract is undefined -%}
{%- set last_frame_to_extract = production_steps|int -%}
{%- endif -%}
{%- if n_frames_to_extract is undefined -%}
{%- set n_frames_to_extract = 5 -%}
{%- endif -%}
{%- if every_nth_frame_to_extract is undefined -%}
{%- set every_nth_frame_to_extract = ( (last_frame_to_extract - first_frame_to_extract)/n_frames_to_extract )|round(1, 'floor')|int -%}
{%- endif -%}
name: {{ machine|default("NEMO",true) }}, {{ title }}, frame extraction
spec:
  _category: {{ worker|default("nemo_noqueue",true) }}
  _files_in:
    data_file:        default.lammps
    joint_traj_file:  default.nc
    reference_file:   reference.lammps

  _files_out:
    reference_file:   default.lammps
    #restored_file:    restored.lammps

  # glob pattern to match output of netcdf2data.py
  local_glob_pattern: 'frame_*.lammps'
  frame_index_regex:  '(?<=frame_)([0-9]+)(?=\.lammps)'

  # netcdf2data.py writes file named frame_0.lammps ... frame_n.lammps
  _tasks:
  - _fw_name: CommandLineTask
    command_spec:
      command: [ netcdf2data.py, --verbose, --frames, {{ first_frame_to_extract|int }}-{{ last_frame_to_extract|int }}-{{ every_nth_frame_to_extract|int }}, default.lammps, default.nc ]
      netcdf2data_stdout: { source: { type: stdout }, target: { type: data } }
      netcdf2data_stderr: { source: { type: stderr }, target: { type: data } }
    outputs: [ netcdf2data_stdout, netcdf2data_stderr ]
    env: python

  # get current working directory
  - _fw_name: PyTask
    func:    os.getcwd
    outputs: [ cwd ]

  # put together absolute glob pattern
  - _fw_name: PyTask
    func:    os.path.join
    inputs:  [ cwd, local_glob_pattern ]
    outputs: [ absolute_glob_pattern ]

  # create list of all output files, probably unsorted [ frame_n.lammps ... frame_m.lammps ]
  - _fw_name: PyTask
    func:    glob.glob
    inputs:  [  absolute_glob_pattern ]
    outputs: [ unsorted_frame_file_list ]

  # nest list of all output files  into {"frame_file_list": [ frame_0.lammps ... frame_n.lammps ] }
  - _fw_name: JoinDictTask
    inputs: [ unsorted_frame_file_list ]
    output: nested_unsorted_frame_file_list

  # ugly utilization of eval: eval(expression,globals,locals) has empty globals {}
  # and the content of "nested_frame_file_list", i.e. {"frame_file_list": [ frame_0.lammps ... frame_n.lammps ] }
  # handed as 2nd and 3rd positional argument. Knowledge about the internal PyTask function call is necessary here.

  # create list of unsorted frame indices, extracted from file names [ n ... m ]
  - _fw_name: PyTask
    func:    eval
    args:    [ '[ int(f[ f.rfind("_")+1:f.rfind(".") ]) for f in unsorted_frame_file_list ]', {} ]
    inputs:  [ nested_unsorted_frame_file_list ]
    outputs: [ unsorted_frame_index_list ]

  # nest list of frame indices into {"unsorted_frame_index_list": [ n ... m ] }
  - _fw_name: JoinDictTask
    inputs: [ unsorted_frame_index_list, unsorted_frame_file_list ]
    output: nested_unsorted_frame_file_list

  # { '1': { type: data, value: frame_1.lammps, frame: 1 } } ... { source: { type: data, value: frame_n.lammps, frame: n } } ]
  - _fw_name: PyTask
    func:    eval
    args:    [ '{ "indexed_frame_file_dict" : { str(i): {"type": "data", "value": f, "frame": i } for i,f in zip(unsorted_frame_index_list,unsorted_frame_file_list) } }', {} ]
    inputs:  [ nested_unsorted_frame_file_list ]
    outputs: [ nested_indexed_frame_file_dict ]

    # create list of nested dicts of all output files
    # [ { type: data, value: frame_0.lammps } ... { type: data, value: frame_n.lammps } ]
    - _fw_name: PyTask
      func:    eval
      args:    [ '[ v for k,v in sorted(indexed_frame_file_dict.items()) ]', {} ]
      inputs:  [ nested_indexed_frame_file_dict ]
    outputs: [ frame_file_dict_list ]

  - _fw_name: ForeachTask
    split: frame_file_dict_list
    task:
      # merge.py called with
      # positional arguments:
      # datafile.lammps       LAMMPS data file to process. (default: 377_SDS_on_AU_1
      #                       11_51x30x2_monolayer_with_counterion_100Ang_stepped.la
      #                       mmps)
      # reffile.lammps        Reference data file containing complete system
      #                       information. (default: 377_SDS_on_AU_111_51x30x2_monol
      #                       ayer_with_counterion_psfgen.data)
      # outfile.lammps        Merged output data file. (default: 377_SDS_on_AU_111_5
      #                       1x30x2_monolayer_with_counterion_100Ang_stepped_parame
      #                       trized.lammps)
      _fw_name: CommandLineTask
      command_spec:
        command:         [ merge.py ]
        frame_file_dict_list:
          source : frame_file_dict_list
        reference_file_dict:
          source: { type: path, value: reference.lammps }
        restored_frame_file_dict_list:
          target: { type: path, value: restored.lammps }

        merge_stdout: { source: { type: stdout }, target: { type: data } }
        merge_stderr: { source: { type: stderr }, target: { type: data } }
      inputs:  [ frame_file_dict_list, reference_file_dict ]
      outputs: [ restored_frame_file_dict_list ]

  metadata:
    state: extract frames
    {{ render_metadata()|indent(4)}}
{% endblock %}
