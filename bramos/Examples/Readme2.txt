This files are launched in bwCloud:
The following yamls files will create a gold substrate pdb file and will add the surfactant molecules on the subtrate (packmol). 

* `example5.yaml`, a workflow to launch the two fireworks:
   - Initialization allows us to enter all the necessary parameters to create a dictionary 
     with a list of all possible combinatinons between surfactants and preassemblies of the structure.
     Besides it constructs a surface with dimensions N x M x L and storages its output N x M x L.pdb in MongoDB
     To make these tasks we use the function run_replicate that is possible in Fireworks using PyTask.
   - Packmol allows us to read the all the combinations of inputs we set up in the first fireworks.
     Then the aggregates of surfactant molecules are preassembled upon the substrate slab via packmol.inp. N x M x L.pdb 
     and a template file, finally we get pdb files with the system name of every combination storage in the MongoDB.
     To make these tasks we run the function run_packmol which appends one branch of fireworks to the initial workflow
     for every possible combination of parameters.
     We can add the number of loops and maximum of interations for the packmol. Otherwise it the set up the defalult parameters.


* `example6.yaml`, this a more extended version of example6, ie it has the same functionality of the previous example, but it
   contains the full steps and only works for one combination. The fireworks are the following.
   -Replicate: As inputs in this fireworks we have to modifiy "replicate.sh N M L 111" and "AddFilesTask: identifiers and paths" with
    the same values. This firework generates the N x M x L .pdb and saves the dimensions we entered and fecths them to next fireworks.
   -Surfactants: We enter in this fireworks the surfactants and join them to dimensions we get in the previous fw, and the fetch them 
    to the next one.
   -Preassembly: We enter all the pressamblies we want to generate for the system and join them to dimensions and surfactants.
   -Aggregates: We enter the number of molecules in the surface, the counter ion and the substrate multiples. And finally we made all the
    possible combinations of system with these paramereters and fecth them as a dictionary.
   -Packmol: It has the same function as the fireworks in example5.

Testuser.py

Functions:
- get_inputs : this function set up a list of the following parameters for each system:
  "sb_multiples":dimensions that with set up in the initialization.
  "sb_unit":sb_unit that with set up in the initialization.
  "sf_nmolecules":sf_nmolecules that with set up in the initialization.
  "counterion": counterion that with set up in the initialization.
  "sb_name": it uses the sb_multiples to create a name for the substrate 
  "sb_measures": it is the division between sb_multiples and sb_unit
  "surfactant": it contains one surfactant of the list of surfactants we entered as inputs.
  "preassembly":it contains one preassembly of the list of preassembly we entered as inputs.
  "system_name": it containts the name of the system concatenating all the parameters listed before.
  Most of the values are fixed for a system except for surfactants and preassemblies, that´s why the "for loop"
  we use in this function only depend on surfactants and preassembly.

- sb_replicate: this function read the inputs we set up, and creates a firework that can create a N M L pdb file and save it in Mongo DB.

- run_replicate: this function read the inputs we set up and the firework that was generated by sb_replicate. Finally this function save the
  inputs in the database and launch the firework sb_replicate.

- run_packmol: This function reads the entries in the database, that is, all the possible combinations that the dictionary contains. 
  Then distinguish each system according to its preassembly and choose its corresponding packing (cylinder, hemicylinder, monolayer, bilayer)
  After that a template for each system it is create and the function launchs a branch of fireworks for each system combination and storages 
  a system_name.pdb for each branch.
--------
get_inputs_single(): it has the same functionality as the get_inputs but only for one combination.
get_dimensions(): it gets the dimensions of the N M L . pdb file and fecth them.
get_surfactants(): it gets the surfactants parameters and concatenates them with the dimensions, finally it fetch them.
get_preassembly(): it gets the preassembly parameters and concatenates them with the dimensions and surfactants, finally it fetch them.


Template files: 
'packmol.inp'

Mongo Database:
'au_cell_P1_111.gro'

This files are launched in Nemo:

* `example8.yaml`, a workflow to launch the two fireworks:
   - inputs allows us to enter all the necessary parameters to run the system one desires.
   - convertToLammps allows us to run the fuction run_prepare_pdb2lmp in order to get the system in a lammps file format.

- run_prepare_pdb2lmp: this function read the inputs we set up and and launch the firework(function) prepare_pdb2lmp
- prepare_pdb2lmp: this function creates a workflow whichs converts a pdb file to a lammps one. It contains the following steps:
First, we modify the pdb file to be readable by GROMACS, then we use gmx_solbate to make the solvation.
Second, we convert the Gromacs file to a pdb one(.tar.gz) .
Third, we convert pdb(.tar.gz) file to a psfgen ones.
Last, we convert psfgen files to a lammps one(psfgen.data).


Also this workflow saves the output files of every step in the database.

Template files: 
'gmx_solvate.sh'
'gmx2b.sh'
'psfgen.pgn'

Mongo Database:
'par_all36_lipid_extended_stripped.prm'
'top_all36_lipid_extended_stripped.rtf'
'1_NA.pdb'
'1_SDS.pdb'







   




    

  