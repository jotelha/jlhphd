# Created by charmm2lammps v1.9.1 on Mo 25. Jun 16:13:55 CEST 2018
# Command: charmm2lammps.pl all36_lipid_extended 1_SDS_on_AU_100_2x4x4_psfgen -water=0.997 -ions -border=0 -center
variable dataFile       string  "1_SDS_on_AU_100_2x4x4_psfgen.data"
variable baseName       string  "1_SDS_on_AU_100_2x4x4_charmmfsw_long_10_12"
variable nvtEqSteps     equal   2500    # 5 ps
variable nptEqSteps     equal   2500    # 5 ps
variable nveProdSteps   equal   5000    # 10 ps

variable temperatureT   equal    298    # K
variable pressureP      equal      1    # atm
variable angleIdWater   equal     11

# Intialization
units          real
# http://lammps.sandia.gov/doc/units.html
    #mass = grams/mole
    #distance = Angstroms
    #time = femtoseconds
    #energy = Kcal/mole
    #velocity = Angstroms/femtosecond
    #force = Kcal/mole-Angstrom, compared to gmx: kJ mol^-1 nm^-1,
        # conversion F_lmp = F_gmx * 0.1 [nm/Ang] / 4.184 [kJ/kcal] ~ gmx / 41.81
        # 1000 kJ / (mol*nm) ~ 25 kCal/(mol*Ang)
    #torque = Kcal/mole
    #temperature = Kelvin
    #pressure = atmospheres, 1 atm = 1013 hPa ~ 100 kPa
    #dynamic viscosity = Poise
    #charge = multiple of electron charge (1.0 is a proton)
    #dipole = charge*Angstroms
    #electric field = volts/Angstrom
    #density = gram/cm^dim

neigh_modify    delay 2 every 1
# This command sets parameters that affect the building and use of pairwise
# neighbor lists. Depending on what pair interactions and other commands 
# are defined, a simulation may require one or more neighbor lists.

atom_style      full
bond_style      harmonic
angle_style     charmm
dihedral_style  charmmfsw
improper_style  harmonic
pair_style      lj/charmmfsw/coul/long 10 12
pair_modify     mix arithmetic
kspace_style    pppm 1e-6

read_data       1_SDS_on_AU_100_2x4x4_psfgen.data

special_bonds   charmm

timestep       2.0 # 0.002 ps = 2 fs

group          water      type  9 10  #  9 - H, 10 - O
group          surface    type  8     #  8 - Au
group          ion        type 12     # 12 - Na+
group          surfactant subtract all water surface ion
group          nonwater   subtract all water


thermo_style   custom step ke pe etotal temp press enthalpy ebond eangle &
  edihed eimp epair evdwl ecoul elong etail vol
thermo         100
thermo_modify  norm no

##############
# minimization
##############
# dump movie nonwater movie 1 ${baseName}_minimization.mp4 type type size 640 480
# dump_modify movie framerate 24

minimize 0.0 10.0 2000 20000
# Perform an energy minimization of the system, by iteratively adjusting atom 
# coordinates. Iterations are terminated when one of the stopping criteria is 
# satisfied. At that point the configuration will hopefully be in local 
# potential energy minimum. More precisely, the configuration should 
# approximate a critical point for the objective function (see below), which 
# may or may not be a local minimum. 
#
#    etol = stopping tolerance for energy (unitless)
#    ftol = stopping tolerance for force (force units)
#    maxiter = max iterations of minimizer
#    maxeval = max number of force/energy evaluations
#
# Either or both of the etol and ftol values can be set to 0.0, in which case 
# some other criterion will terminate the minimization.

write_data     ${baseName}_minimized.lammps

reset_timestep  0
# undump movie

###################
# NVT equilibration
###################
fix             equilibrateNVT all nvt temp ${temperatureT} ${temperatureT} 100 tchain 1
# WARNING: Fix rattle should come after all other integration fixes  (../fix_rattle.cpp:147)
fix             rigidHbonds all rattle 1e-6 500 0 m 1.0 a ${angleIdWater}
# The b constraint lists bond types that will be constrained. 
# The t constraint lists atom types. All bonds connected to an
#  atom of the specified type will be constrained. The m constraint 
# lists atom masses. All bonds connected to atoms of the specified 
# masses will be constrained (within a fudge factor of MASSDELTA specified 
# in fix_shake.cpp). The a constraint lists angle types. If both bonds in 
# the angle are constrained then the angle will also be constrained if its 
# type is in the list.
# The mentioned MASSDELTA is defined as 0.1 (16Mar18).
# The fix rattle command modifies forces and velocities and thus should be 
# defined after all other integration fixes in your input script. If you 
# define other fixes that modify velocities or forces after fix rattle operates,
# then fix rattle will not take them into account and the overall time 
# integration will typically not satisfy the RATTLE constraints. You can 
# check whether the constraints work correctly by setting the value of 
# RATTLE_DEBUG in src/fix_rattle.cpp to 1 and recompiling LAMMPS.
# The degrees-of-freedom removed by SHAKE bonds and angles are accounted for in 
# temperature and pressure computations. Similarly, the SHAKE contribution to 
# the pressure of the system (virial) is also accounted for.

velocity        all create ${temperatureT} 29061988 rot yes mom yes dist gaussian

restart         500 ${baseName}.restart1 ${baseName}.restart2


# dump movie nonwater movie 4 ${baseName}_nvtEqulibration.mp4 type type size 640 480
# dump_modify movie framerate 24

dump            dumpPng nonwater image ${nvtEqSteps} ${baseName}_nvtEquilibration.*.png &
                  type type
dump            dumpNetCDF all netcdf 100 ${baseName}_nvtEquilibration.nc &
                  id mol type x y z vx vy vz
run             ${nvtEqSteps}
write_data      ${baseName}_nvtEquilibrated.lammps
reset_timestep  0

unfix           equilibrateNVT
unfix           rigidHbonds
undump          dumpPng
undump          dumpNetCDF
# undump          movie

###################
# NPT equilibration
###################
fix             rigidHbonds all shake 1e-6 500 0 m 1.0 a ${angleIdWater}
fix             equilibrateNPT all npt temp ${temperatureT} ${temperatureT} &
                  100 iso ${pressureP} ${pressureP} 100 tchain 1 pchain 1
#                                           ^                     Tstart / K
#                                                           ^     Tstop
#                 ^                                               Tdamp/steps
#                         ^                                       Pstart/atm
#                                      ^                          Pstop
#                                                   ^             Pdamp/steps 
# fix             rigidHbonds all rattle 1e-6 500 0 m 1.0 a ${angleIdWater}

# dump            movie nonwater movie 4 ${baseName}_nptEqulibration.mp4 type type size 640 480
# dump_modify     movie framerate 24

dump            dumpPng    nonwater image ${nptEqSteps} ${baseName}_nptEquilibration.*.png &
                  type type
dump            dumpNetCDF all netcdf 100 ${baseName}_nptEquilibration.nc id &
                  mol type x y z vx vy vz
run             ${nptEqSteps}
write_data      ${baseName}_nptEquilibrated.lammps
reset_timestep  0

unfix           equilibrateNPT
unfix           rigidHbonds
undump          dumpPng
undump          dumpNetCDF
# undump          movie

################
# NVE production
###############

fix             production all nve
fix             rigidHbonds all rattle 1e-6 500 0 m 1.0 a ${angleIdWater}

# dump            movie nonwater movie 8 ${baseName}_nveProduction.mp4 type type size 640 480
# dump_modify     movie framerate 24
dump            dumpPng    nonwater image ${nveProdSteps} ${baseName}_nveProduction.*.png type type
dump            dumpNetCDF all netcdf 100 ${baseName}_nveProduction.nc id mol &
                  type x y z vx vy vz
# fix             RigidOHBonds all shake 1e-6 20 0 b 1 a 1
# http://lammps.sandia.gov/doc/fix_shake.html
# If you use a tolerance that is too large or a max-iteration count that is too
# small, the constraints will not be enforced very strongly, which can lead to
# poor energy conservation. You can test for this in your system by running a
# constant NVE simulation with a particular set of SHAKE parameters and
# monitoring the energy versus time.
# If both bonds in the angle are constrained then the angle will also be
# constrained if its type is in the list.
# If you define fixes (e.g. fix efield) that add additional force to the atoms
# after fix shake operates, then this fix will not take them into account and
# the time integration will typically not satisfy the SHAKE constraints.
# The solution for this is to make sure that fix shake is defined in your input
# script after any other fixes which add or change forces (to atoms that fix
# shake operates on).

# Compute diffusivity by Einstein relation:

# mean-squared displacement:
# Define a computation that calculates the mean-squared displacement (MSD) of
# the group of atoms, including all effects due to atoms passing thru periodic
# boundaries.
compute         msd surfactant msd com yes
# http://lammps.sandia.gov/doc/compute_msd.html
# ID, group-ID are documented in compute command
# msd = style name of this compute command
# zero or more keyword/value pairs may be appended
# keyword = com or average
# A vector of four quantities is calculated by this compute.
# The first 3 elements of the vector are the squared dx,dy,dz displacements,
# summed and averaged over atoms in the group. The 4th element is the total
# squared displacement, i.e. (dx*dx + dy*dy + dz*dz), summed and averaged
# over atoms in the group.
# The vector values are intensive. The vector values will be in distance^2 units.

compute         moleculeChunks surfactant chunk/atom molecule nchunk once &
                                            ids once compress yes 
compute         chunkCount     surfactant property/chunk moleculeChunks count
compute         molcom         surfactant com/chunk moleculeChunks
compute         molmsd         surfactant msd/chunk moleculeChunks
# http://lammps.sandia.gov/doc/compute_msd_chunk.html
# This compute calculates a global array where the number of rows = the number 
# of chunks Nchunk as calculated by the specified compute chunk/atom command. 
# The number of columns = 4 for dx,dy,dz and the total displacement. These 
# values can be accessed by any command that uses global array values from 
# a compute as input. See this section for an overview of LAMMPS output options.
## test:

info all out overwrite lmpstate.txt

fix vectorOut surfactant ave/time 100 1 100 c_chunkCount c_molcom[*] c_molmsd[*] & 
  file ${baseName}_moleculeProperties.out mode vector

# Einstein relation: 6Dt ~= <|r(t)-r(0)|>^2
# factor of 6 in 2 variables is for 3d

# dt = 2fs
variable        Dtwopoint equal c_msd[4]/6/(step*dt+1e-15)
variable        DmolTwopoint equal c_molmsd[4][1]/6/(step*dt+1e-15)

variable        DxMolTwopoint equal c_molmsd[1][1]/2(step*dt+1e-15)
variable        DyMolTwopoint equal c_molmsd[2][1]/2(step*dt+1e-15)
variable        DzMolTwopoint equal c_molmsd[3][1]/2(step*dt+1e-15)

# store Dtwopoint every 10 step = 20fs
fix             gather_Dtwopoint surfactant vector 1 c_msd[4]
fix             gather_DmolTwopoint surfactant vector 1 c_molmsd[4][1]
fix             gather_DxMolTwopoint surfactant vector 1 c_molmsd[1][1]
fix             gather_DyMolTwopoint surfactant vector 1 c_molmsd[2][1]
fix             gather_DzMolTwopoint surfactant vector 1 c_molmsd[3][1]

# http://lammps.sandia.gov/doc/fix_vector.html
# Use one or more global values as inputs every few timesteps, and simply store
# them. For a single specified value, the values are stored as a global vector
# of growing length
variable        Dfitslope equal slope(f_gather_Dtwopoint)/6/(1*dt)
variable        DmolFitslope equal slope(f_gather_DmolTwopoint)/6/(1*dt)
variable        DxMolFitslope equal slope(f_gather_DxMolTwopoint)/2/(1*dt)
variable        DyMolFitslope equal slope(f_gather_DyMolTwopoint)/2/(1*dt)
variable        DzMolFitslope equal slope(f_gather_DzMolTwopoint)/2/(1*dt)

# http://lammps.sandia.gov/doc/variable.html
# The slope() function uses linear regression to fit a line to the set of
# points, equally spaced by 1 in their x coordinate:
# (1,V1), (2,V2), ..., (N,VN), where the Vi are the values in the global vector
# of length N. The returned value is the slope of the line. If the line has a
# single point or is vertical, it returns 1.0e20.

# Compute diffusivity by VACF
compute         vacf surfactant vacf
# http://lammps.sandia.gov/doc/compute_vacf.html
# A vector of four quantities is calculated by this compute.
# The first 3 elements of the vector are vx * vx0 (and similarly for the y and z
# (components), summed and averaged over atoms in the group. Vx is the current
# x-component of velocity for the atom, vx0 is the initial x-component of
# velocity for the atom. The 4th element of the vector is the total VACF, i.e.
# (vx*vx0 + vy*vy0 + vz*vz0), summed and averaged over atoms in the group.

#fix             gather_vacf surfactant ave/time 1 1 1 c_vacf[4] #file tmp.vacf
fix             gather_vacf surfactant vector 1 c_vacf[4] # computes v(0)*v(t)
fix             gather_xvacf surfactant vector 1 c_vacf[1] # computes v(0)*v(t)
fix             gather_yvacf surfactant vector 1 c_vacf[2] # computes v(0)*v(t)
fix             gather_zvacf surfactant vector 1 c_vacf[3] # computes v(0)*v(t)


variable        Dvacf equal 1/3*dt*trap(f_gather_vacf) 
variable        Dxvacf equal dt*trap(f_gather_xvacf) 
variable        Dyvacf equal dt*trap(f_gather_yvacf) 
variable        Dzvacf equal dt*trap(f_gather_zvacf) 
# factor 1/3 due to 3d, 3 components summed in c_vacf[4]
# http://lammps.sandia.gov/doc/variable.html
# The trap() function is the same as sum() except the first and last elements
# are multiplied by a weighting factor of 1/2 when performing the sum.
# This effectively implements an integration via the trapezoidal rule on the
# global vector of data. I.e. consider a set of points, equally spaced by 1 in
# their x coordinate: (1,V1), (2,V2), ..., (N,VN), where the Vi are the values
# in the global vector of length N. The integral from 1 to N of these points is
# trap(). When appropriately normalized by the timestep size, this function is
# useful for calculating integrals of time-series data, like that generated by
# the fix ave/correlate command.

# The integral of the VACF versus time is proportional to the diffusion
# coefficient of the diffusing atoms.

fix scalarOut surfactant ave/time 100 1 100 v_Dtwopoint v_DmolTwopoint &
  v_DxMolTwopoint v_DyMolTwopoint v_DzMolTwopoint &
  v_Dfitslope v_DmolFitslope v_DxMolFitslope v_DyMolFitslope v_DzMolFitslope &
  v_Dvacf Dxvacf Dyvacf Dzvacf&
  file ${baseName}_transport_coefficient_related.out mode scalar

#thermo_style   custom step ke pe etotal temp press enthalpy ebond eangle &
#  edihed eimp epair evdwl ecoul elong etail vol c_msd[*] c_molmsd[*] c_vacf[*] &
#  v_Dtwopoint v_DmolTwopoint v_Dfitslope v_DmolFitslope v_Dvacf
# thermo_style   custom step ke pe etotal temp press enthalpy ebond eangle &
#   edihed eimp epair evdwl ecoul elong etail vol c_msd[*] c_vacf[*] &
#  v_Dtwopoint v_Dfitslope v_Dvacf
# thermo_modify  norm no

# averageing every 2ps = 2000fs
# why do c_thermo_ecoul c_thermo_epair c_thermo_ebond c_thermo_eangle not work?
#fix average all ave/time 1 500 1000 c_thermo_pe c_thermo_temp c_thermo_press &
#  c_msd[*] c_mol_msd[*] c_vacf[*]  v_Dtwopoint v_DmolTwopoint v_Dfitslope &
#  v_DmolFitslope v_Dvacf mode scalar file ${baseName}_2ps_ave.out
# fix average all ave/time 1 500 1000 c_thermo_pe c_thermo_temp c_thermo_press &
#   c_msd[*] c_vacf[*]  v_Dtwopoint v_Dfitslope &
#   v_Dvacf mode scalar file ${baseName}_2ps_ave.out
# fix          average all ave/time     1   500     1000 c_thermo_pe c_thermo_temp c_thermo_press c_thermo_epair c_thermo_ebond c_thermo_eangle v_Dtwopoint v_Dfitslope v_Dvacf mode scalar file ${baseName}_2ps_ave.out
#                                       ^                    use every step for everaging
#                                           ^                use only 500 step = 1ps to construct average
#                                                   ^        average every 1000 step = 2ps


# Run the simulation
# 0.6ns = 0.6e3ps = 0.6e6fs = 0.3e6fs = 300,000 step
# 1ns = 1e3ps = 1e6fs = 500,000 steps
# 4.1ns = 4.1e6fs = 2,050,000
# 10ns = 10e6fs = 5,000,000 steps
run            ${nveProdSteps}
write_data     ${baseName}_final_config.lammps
